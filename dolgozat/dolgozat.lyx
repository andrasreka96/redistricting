#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass report
\begin_preamble
\usepackage{algorithm,algpseudocode}
\usepackage{amsmath}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language magyar
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Szavazókörzetek újraosztása
\end_layout

\begin_layout Author
András Réka
\end_layout

\begin_layout Chapter
Bevezetés
\end_layout

\begin_layout Standard
A modern demokráciák fő célja a politikai rendszer átláthatóvá tétele kellene
 hogy legyen.
 Így nyerhető vissza az emberek bizalma a demokratikus rendszerekbe, mielőtt
 véglegesen valamilyen szélsőséges megoldáshoz fordulnának.
 Ezt a célt szolgálják a politikai ülések, perek élő közvetítései.
 Azonban még mindig vannak olyan folyamatok, amelyek azt az érzetet ébresztik
 a szavazóban, hogy a döntések tőle függetlenül, zárt ajtók mögött zajlanak.
 Ezen folyamatok közé tartozik a szavazókörzetek újra osztása.
 Jobb esetben, az újraosztási tervet egy függetlennek nevezett bizottság
 készíti el, amelyet majd valamely törvényhozó szerv elfogad.
 Az emberek jogosan sejtenek, a gyakran földrajzi szempontból irracionálisnak
 tetsző határvonalak mögé, rejtett szándékokat.
 
\emph on
Redistricting 
\emph default
és 
\emph on
Gerrymandering
\emph default
, ez a két kifejezés elválaszthatatlanná vált.
 Az újra osztás elkerülhetetlen, ezért a választókerület-manipulációt kell
 megszüntetni.
 A dolgozatban bemutandó QGIS plug-in célja az újraosztási folyamat mindenki
 számára követhetővé tétele és teljes automatizálása.
 A felosztást egy több-célfüggvényű, a szimulált hűtés módszerét használó
 algoritmus végzi.
 Az által, hogy eltűnik a folyamatból az emberi tényező elkerülhetővé válnak
 az olyan felosztások, amelyek valamely pártnak vagy etnikai csoportnak
 szándékosan kedveznek.
 Ugyanakkor az, hogy a program milyen kritériumok alapján végzi a felosztást,
 mindenki számára áttekinthető, így az újraosztás körüli gyakori bizalmatlanság
 is megszűnne.
 Ez remélhetőleg csökkentené a kételyeket, a többségi elven müködő demokratikus
 rendszerek legitimitását illetően, és megszüntetné a történelem során oly
 sokszor előforduló, önkényes határvonalakat.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename NORTH CAROLINA'S 12TH DISTRICT.png
	lyxscale 40
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Észak-Karolina jelenlegi 12.
 választói körzete
\end_layout

\end_inset


\end_layout

\end_inset

 A következő fejezetben megmagyarázásra kerül néhány, a probléma átlátásához
 szükséges, politikai fogalom.
 Majd az ezt követő részben bemutatásra kerülnek az alkalmazás által használt
 technológiák, elsősorban a GIS, majd konrétan a QGIS.
 Ez után a felosztást végző algoritmus, néhány elengedhetetlen kritériumnak
 megfeleltethető függvény, és végül megvizsgáljuk a program által meghatározott
 lehetséges felosztásait Románia megyéinek.
\end_layout

\begin_layout Chapter
Politika
\end_layout

\begin_layout Section
Redistricting
\end_layout

\begin_layout Standard
A redistricting kifejezés a választói körzetek határainak újra rajzolását
 jelenti.
 Erre a folyamatra időnként szükség van, mert egy terület lakosságának a
 száma nagy mértékben változhat.
 Választói szemszögből, ez azt jelenti, hogy a sürűbben lakott körzetek
 polgárainak szavazata kevesebbet ér, mint a ritkábban lakott kerületekben
 élő polgároké.
 Ez ellentmond a demokrácia 'egy ember egy szavat' elvével.
 
\end_layout

\begin_layout Section
Mallaize
\end_layout

\begin_layout Section
Gerrymandering
\end_layout

\begin_layout Standard
A szavazókörzetek újraosztása mégsem az igazságos választásokkal fonódott
 össze, hanem a gerrymandering fogalmával.
 A gerrymandering Elbridge Gerry szenátorról kapta a nevét, aki jóváhagyott
 egy olyan körzet felosztási tervet,amely jelentős előnyhöz jutatta a demokraták
at.
 A különös alakú választókerület egy szalamandrához hasonlított.
 A Gerry névhez illesztve az angol 'salamander' szót megkapjuk a gerrymandering
 kifejezést.
 A gerrymandering vagy választókerület-manipuláció a választói körzeteknek
 egy olyan felosztását jelenti, amely kedvező/kedvezőtlen helyzetbe hozhat
 valamely pártot,etnikai,nyelvi,vallási csoportot,stb..
 A választási eredmények ilyen manipulációjá kiváltképp a többségi elven
 müködő demokratikus rendszerekben fordulhat elő.
 Ezek a rendszerek nem arányosan választják meg képviselőiket, az a képviselő
 nyer aki a szavazatok többségét kapta, így mindig lesznek kárba veszett
 szavazatok.
 Tegyük fel, hogy egy 100 szavazóból álló körzetben, A párt 90 szavazatot
 kap, B párt 10-et.
 Ebben az esetben B párt vesztesége 10, A párté 39 (90 minusz a győzelemhez
 szükséges 51 szavazat).
 A választókerület-manipulációt végző párt arra törekszik, hogy az ellenfél
 kárba veszett szavazatait maximalizálja, míg az ő esetében minimalizálja
 a veszteséget.
\end_layout

\begin_layout Chapter
GIS, QGIS, Python
\end_layout

\begin_layout Standard
A GIS(Geographic Information System) egy számítógépes rendszer, amelyet
 földrajzi helyhez kapcsolódó adatok megjelenítésére, elemzésére és tárolására
 dolgoztak ki.
 Az elképzelés a következő:
\end_layout

\begin_layout Enumerate
földrajzi koordinátákkal rendelkező adatok gyűjtése
\end_layout

\begin_layout Enumerate
adatok modellezése
\end_layout

\begin_layout Enumerate
adatok elemzése
\end_layout

\begin_layout Enumerate
eredmények megjelenítése térképen
\end_layout

\begin_layout Section
Adatgyűjtés
\end_layout

\begin_layout Standard
A GPS-el felszerelt telefonok, autók folyamatosan képesek térbeli adatokat
 szolgáltatni,és a szatelitek már mindenki számára elérhető felvételeket
 készítenek a Föld felszínéről.
\end_layout

\begin_layout Section
Adatmodellezés
\end_layout

\begin_layout Standard
A GIS kétféle modellt használ a térbeli adatok tárolására.
 Az egyik a raszteres(grid) adatmodell.
 Ez egy pixelekből felépülő adatmodell, ahol minden pixelhez azonos méretü
 területi egységet rendelünk.
 A pixelek sorokban és oszlopokban helyezkednek el, ez adja az adatok geometria
 jellemzőit, ugyanakkor minden mezőhöz értékek sorát rendelhetjük, mindegyiket
 megfeleltetve egy-egy tulajdonságnak.
 Gyakori raszter adat fájlformátumok: JPEG2000, IMG, GeoTIFF.
 A második adatmodell a vektoros adatmodell, ami pontokat (x,y koordináták)
 tartalmaz, és arra vonatkozó szabályokat, hogy a pontok miként alkotnak
 vonalakat és poligonokat (zárt vonalak).
 Ezen adatok tárolása gyakran shapefájlokban történik.
 Ez igazábol legkevesebb három másik különböző formátumú fájlt foglal magába.
 A DBF (dBase file) egy adatbázis tábla, ez tartalmazza az adataink attribútumai
t.
 Az shp kiterjesztésű fájl tartalmazza a földrajzi adatokat és ehhez még
 tartozik egy index fájl.
\end_layout

\begin_layout Section
Vetítés
\end_layout

\begin_layout Standard
Mivel a Föld pontjainak térképre való vetítésének több módja is van, a vetítésre
 vonatkozó információk tárolása is szükséges, amennyiben a térképeket egymásra
 akarjuk illeszteni.
 A használt vetítés tárolása a projection (.prj) fájlokban történik.
 A térképvetítés matematikai transzformációk sorozata, amely során egy szferikus
 felület felszínén található pontok síkba vetitődnek.
 Először a Föld szabálytalan felszínét egy szabályos geometria alakzatként
 kell kezelnünk, mint a gömb vagy szferoid, aztán az így kapott felületet
 vetíthetjük síkba.
 Ez a folyamat mindig valamilyen torzúlást eredményez, ezért van olyan sok
 féle vetítés.
 Van amelyik a pontok közti távolságot őrzi meg, mások a levetített rész
 területét, formáját tartják meg.
 Nem létezik egy egységes vetítési eljárás.
 Vannak elterjedtebbek,mint például a Google Maps és a Mango Map által használt
 Web Mercator vetítés.
\end_layout

\begin_layout Section
Adatelemzés
\end_layout

\begin_layout Standard
A QGIS számos előre beépített statisztikai és geometria eszközt nyújt az
 adatok elemzésére.
 Például: interpolálás, heatmappek generálása, GPS adatok betöltése, SQL
 lekérdezések végrehajtása (számolhatunk átlagokat, előfordulásokat, összegzések
et) , convex hurkok meghatározása, osztályozás, kontúrok meghúzása.
 Mindezek mellett lehetőséget nyújt az adatok elemzésére általunk írt python
 vagy c++ kóddal.
 Amikor betöltünk egy layert a QGIS felépíti az annak megfelelő objektumot,
 amely a QgsInterface osztály iface nevű instanciáján keresztűl érhetünk
 el.
 Az így kapott layer objektumtól kérthetünk egy iterátort a featurekhez.
 A featurek tartalmazzák a geometria információkat (koordináták,terület,stb..)
 és az adatbázishoz tartozó attribútumok értékeit.
 Ha a scriptet külső forrásból futtatjuk, importolnunk kell a qgis.core nevű
 könyvtárat, ez tartalmazza az alap GIS funkcionalitásokat.
 Pythonban írhatunk pluginokat a QGIS-hez, vagy készíthetünk egy különálló
 applikációt
\end_layout

\begin_layout Section
Felhasználás
\end_layout

\begin_layout Standard
Az adatok reprezentálásának és elemzésének a GIS által biztosított módját
 sok területen használják: az epidemiológusok a vírusok globális terjedését
 vizsgálják, a kriminológusok bűnözési mintákat keresnek, a geológusok a
 Föld fizikai elváltozásait megfigyelve előre jelzik a földmozgásokat,vagy
 lehetséges fosszilis erőforrásokat keresnek, a globális felmelegedéssel
 kapcsolatos kutatásokban is használnak földrajzi információs rendszereket.
\end_layout

\begin_layout Chapter
Algoritmus
\end_layout

\begin_layout Section
A szimulált hűtés módszere
\end_layout

\begin_layout Standard
A szimulálát hűtés módszere egy metaheurisztikus algoritmus, amelyet kombinatori
kus optimalizációs problémák megoldására használnak.
 A kombinatorikus optimalizálás, olyan optimalizációs problémákat old meg,
 ahol a megoldástér véges.
 A szimulált hűtésnek több változata is van: Párhuzamos Szimulált Hűtés,
 Gyors Szimulált Hűtés, Adaptív Szimulált Hűtés.
 A továbbiakban a Klasszikus Szimulált Hűtés módszerét tárgyaljuk, amelyet
 Kirkpatrick, Gelatt, és Vecchi vezetett be 1983-ban [2] , optimalizációs
 problémák megoldására.
 A cikkben leírják a termodinamikai rendszerek viselkedését, majd megmutatják
 hogyan használható az, mint optimalizációs technika.
 Egy termodinamikai rendszert különböző változók összessége ír le (hőmérséklet,e
nergia,nyomás,entrópia,stb..), míg egy metaheurisztikus algoritmusnak csupán
 két eszközre van szüksége (költségfüggvény, szomszédos megoldást generáló
 függvény).
 A megfeleltetés a következő: az optimalizációhoz használt költségfüggvény
 a rendszer energiaszintjének felel meg.
 Amikor a rendszer eléri az egyensúlyi állapotát az energia minimális.
 A cél a rendszer egyensúlyi állapotának az elérése, vagyis a költségfüggvény
 minimumának a megtalálása.
 Egy szomszédos állapotot a jelenlegi állapoton eszközölt random perturbációk
 által kapunk meg, ez a rendszeren belüli atommozgásoknak feleltethető meg.
 Bevezetünk egy hőmérséklet változót a termodinamikai rendszerek mintájára,
 amely szabályozza a keresésünk viselkedését.
 Ahhoz, hogy megtaláljuk egy anyag egyensúlyi állapotát nem elégendő ha
 lehűtjük.
 Az analógiát követve, a keresés alacsony hőmersékleten azt jelenti, hogy
 mindig csak a jobb megoldásokat fogadjuk el, gyakorlatilag lokális minimumot
 keresünk.
 Ha stabil kristályokat akarunk kapni, először forráspont fölé kell melegíteni
 az anyagot, majd lassan hűteni, elegendő időt hagyva a molekuláknak, hogy
 kristályokat formáljanka.
 Nagy hőmérsékleten a molekulák kaotikus mozgást végeznek, ennek megfelelően
 az algoritmus is nagy ugrásokat tesz a megoldás térben, így elkerülhető
 az, hogy lokális minimumba ragadunk.
 Azt hogy a keresés mekkora valószínűséggel lép a jelenleginél rosszabb
 állapotba a rendszer aktuális hőmérséklete befolyásolja.
 Az iterációk során akkor fogadunk el egy új megoldást, ha az jobbnak bizonyúl,
 mint a jelenlegi megoldás.
 Amennyiben nem alacsonyabb az új megoldásunk költségfüggvényének az értéke,
 akkor a jelenlegi megoldást a Metropolis kritérium alapján,
\begin_inset Formula $\exp((E-E_{0})/T)$
\end_inset

 valószínűséggel cseréljük le.
 Ahol E az aktuális megoldás objektív értéké, E
\begin_inset Formula $_{0}$
\end_inset

 a szomszédos megoldás objektív értéke, T a rendszer hőmérséklete.
\end_layout

\begin_layout Section
Több-célfüggvényű algoritmus újraosztáshoz
\end_layout

\begin_layout Standard
A több-célfüggvényű algoritmus különböző kritériumokat figyelembe véve optimaliz
ál.
 A cél olyan (K,U) párosításokat találni, amelyek legnagyobb mértékben megfeleln
ek az általunk definiált objektív függvényeknek.
 K a körzeteket jelöli, U a unitokat.
 A unitok a létező legkisebb közigazgatási egységei a felosztandó országnak.
 Az ország egy lehetséges felosztása, vagyis egy megoldás, olyan (K,U) párok
 összessége, ahol minden körzet előre meghatározott számú unitot foglal
 magába , és egy unit csak egy körzethet tartozhat.
 Amikor összehasonlítunk két megoldást, ahol V az aktuális megoldás, V'
 a szomszédos megoldás, három lehetséges eset van:
\end_layout

\begin_layout Enumerate
V' minden objektív függvény szerint jobb megoldásnak bizonyúl
\end_layout

\begin_layout Enumerate
V' csak bizonyos objektív függvényekre mutat jobb eredményt
\end_layout

\begin_layout Enumerate
V' minden objektív függvény szerint rosszabb megoldásnak bizonyúl
\end_layout

\begin_layout Standard
A megoldásainkat egy olyan halmazba gyűjtjük, amely a fenti eseteknek megfelelő
 szabályok szerint bövűl.
 Ha V' dominál más megoldásokat (1 eset), átveszi egy dominált megoldás
 helyét és súlyait.
 Azt a megoldást fogja lecserélni, amelyiknél a leginkább jobbnak bizonyúl.
 Ezt azt jelenti, hogy összehasonlitódnak a objektív függvények súlyozott
 összegei, és amelyiknél V' súlyozott összege (a súlyokat attól a megoldástól
 kölcsönzi, amellyel éppen összehasonlitódik) a legkisebb, az a megoldás
 lesz helyettesítve.
 Ha az új megoldás nem dominál (nem igaz az 1.
 eset) és nem dominált (nem igaz a 3.
 eset), akkor a halmazhoz adódik.
 Ha V' dominált valamely megoldás által, nem kerül a halmazba, viszont a
 szimulált hűtésnél leírt valószínűség szerint felválthatja a jelenlegi
 megoldást.
 Amikor egy új megoldás kerül a halmazba, mindig hozza rendelődik egy random
 választott súlyvektor az előre meghatározott súlyok listájából.
 Az algoritmus végére minden súlyvektorhoz fog legalább egy nem dominált
 megoldás tartozni.
 Egy lehetséges algoritmus annak eldöntésére, hogy egy megoldás dominált-e
 más megoldások által, illetve dominál-e más megoldásokat, k darab célfüggvény
 esetén:
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Dominálás
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
Require{$k
\backslash
geq 1$}
\end_layout

\begin_layout Plain Layout


\backslash
State dominalt
\backslash
gets false
\end_layout

\begin_layout Plain Layout


\backslash
State dominaltak
\backslash
gets
\backslash
emptyset
\end_layout

\begin_layout Plain Layout


\backslash
For{$s
\backslash
in
\backslash
mathcal Pareto $}
\end_layout

\begin_layout Plain Layout


\backslash
State UdominaltSaltal
\backslash
gets true
\end_layout

\begin_layout Plain Layout


\backslash
State SdominaltUaltal
\backslash
gets true
\end_layout

\begin_layout Plain Layout


\backslash
For{$i=1,..,k$}
\end_layout

\begin_layout Plain Layout


\backslash
State UdominaltSaltal
\backslash
gets UdominaltSaltal and s.objektiv(i)<u.objektiv(i)
\end_layout

\begin_layout Plain Layout


\backslash
State SdominaltUaltal
\backslash
gets SdominaltUaltal and u.objektiv(i)<s.objektiv(i)
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State dominalt
\backslash
gets dominalt or UdominaltSaltal
\end_layout

\begin_layout Plain Layout


\backslash
If{SdominaltUaltal}
\end_layout

\begin_layout Plain Layout


\backslash
State $dominaltak
\backslash
gets dominaltak
\backslash
cup
\backslash
left
\backslash
{s
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

A szimulált hűtés több célfüggvény esetén:
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Szimulát hűtés több célfüggvénnyel
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State legyen U a kezdeti megoldas
\end_layout

\begin_layout Plain Layout


\backslash
State legyen T a kezdeti kezdeti homerseklet
\end_layout

\begin_layout Plain Layout


\backslash
State $pareto
\backslash
gets
\backslash
emptyset$
\end_layout

\begin_layout Plain Layout


\backslash
State $pareto
\backslash
gets pareto
\backslash
cup
\backslash
left
\backslash
{U
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
While{$T
\backslash
neq fagyaspont$ }
\end_layout

\begin_layout Plain Layout


\backslash
For{$i=1,..,maxiteracio$}
\end_layout

\begin_layout Plain Layout


\backslash
State $V
\backslash
gets szomszed(U)$
\end_layout

\begin_layout Plain Layout


\backslash
If{V dominans}
\end_layout

\begin_layout Plain Layout


\backslash
State pareto.update(V)
\end_layout

\begin_layout Plain Layout


\backslash
State U
\backslash
gets V
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
If{V nem dominalt}
\end_layout

\begin_layout Plain Layout


\backslash
State $pareto
\backslash
gets pareto
\backslash
cup
\backslash
left
\backslash
{V
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout


\backslash
State U
\backslash
gets V
\end_layout

\begin_layout Plain Layout


\backslash
Else
\end_layout

\begin_layout Plain Layout


\backslash
If{random(0,1) <= exp(obj(U)-obj(V)/T)}
\end_layout

\begin_layout Plain Layout


\backslash
State U
\backslash
gets V
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
State $T
\backslash
gets T * hutes$
\end_layout

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Redistricting
\end_layout

\begin_layout Section
Általánosan
\end_layout

\begin_layout Standard
A megírt program a szimulált hűtés módszerével generálja egy ország megyéinek/ál
lamainak/tartományainak lehetséges körzetekre való felosztását.
 A célfüggvények és a hozzájuk tartozó súlyok tetszőlegesen megadhatóak.
 A pythonban írt plug-in a QGIS-ből futtatható.
 A programnak szüksége van egy shapefájlra, amely tartalmazza a felosztandó
 megyéket, és egy másik fájlra amely a felosztandó ország közigazgatási
 egységeit (unit) tartalmazza.
 A két fájlhoz tartozó adatbázis tábláknak összekapcsolhatóknak kell lenniük
 a megye azonosítók szerint, tehát tudnunk kell, hogy egy közigazgatási
 egység melyik megyéhez tartozik.
 A későbbiekben egy unit szomszédainak a bejárására gyakran kerűl sor, ezért
 a shapefájlok első használata alkalmával egy scriptet is le kell futtatni,
 amely bővíti egy attribútummal a unitokat tartalmazó adatbázis táblát.
 Az új attribútum az adott unit szomszédos unitjainak az azonosítóját tárolja.
 Ez később rengeteg futási időt nyer majd a körzetek változtatásához szükséges
 műveletek során.
 A plug-in könyvtár-struktúrája tartalmaz egy config.yaml elnevezésű fájlt,
 ezt változtatva állíthatjuk be a paramétereinket.
 Elsősorban megkell adni a shapefájlainkban szereplő attribútumok elnevezéseit,
 ezek helyes ismerete nélkül a program nem lesz futtatható.
 Megkell mondanunk összesen hány körzetet akarunk látni a végső felosztásban.
 A további paraméterek az optimalizáló algoritmus viselkedését befolyásolják,
 ezek változtatása nélkűl is használható a program.
 A szimulált hűtés módszerének olyan paramétereit változtathatjuk, mint
 a kezdeti és végső hőmérséklet, a hűtés mértéke és a hőmérsékletenkénti
 iteráció.
 Beállítható a megoldás halmaz maximális mérete és a költségfüggvényekhez
 rendelhető lehetséges súlyok listája.
 Az is megmondható, hogy egy körzethez minimum hány unitnak kell tartoznia.
 A használt költségfüggvényeket az objectives.py fájl tartalmazza, ezek bővítése
 értelemszerűen nem adható meg a konfigurációs fájlban.
 Amennyiben újabb függvényt szeretnénk egy megoldás kiértékeléséhez adni
 azt implementálnunk kell az objectives.py fájlban.
 A program indítás után iterációnként loggolni fogja a megoldáshalmaz viselkedés
ét.
 A hőmérséklet lehűlése után a legjobb megoldás megjelenik a QGIS grafikus
 felületén, úgy hogy az ugyanazon körzetekhez tartozó unitok azonos színűek
 lesznek.
\end_layout

\begin_layout Section
Objektív Függvények
\end_layout

\begin_layout Standard
A program alapértelmezetten két függvényt használ a megoldások kiértékelésénél.
 Ezek a függvények a gerrymandering és a malapportionment elkerülését szolgálják.
 A 
\begin_inset Formula $C_{1}$
\end_inset

 függvény azt méri, hogy a populáció mennyire oszlik el egyenletesen a körzetek
 között.
 Minnél alacsonyabb a függvény értéke, annál egyenletesebb az eloszlás.
 A használt függvényt az IFE (Instituto Federal Electoral) határozta meg,
 és használta a 2006-os mexicói újra osztások során:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
C_{1}(P)=\sum_{e\epsilon E}(\frac{P_{e}}{d_{e}*M})^{2}\sum_{s\epsilon S}(\frac{P_{s}}{P_{e}}-\frac{1}{n})^{2}
\]

\end_inset

Ahol 
\begin_inset Formula $P=\{Z_{1},Z_{2},...,Z_{n}\}$
\end_inset

 egy felosztása az országnak, úgy hogy 
\begin_inset Formula $Z_{s}=\{U_{1},U_{2},...,U_{s_{k}}\}$
\end_inset

, 
\begin_inset Formula $Z_{s}$
\end_inset

 az 
\emph on
s
\emph default
 körzet unitjainak a halmaza, és 
\emph on
s
\emph default
 körzet valamely 
\emph on
e 
\emph default
megyéhez tartozik.
 
\begin_inset Formula $P_{e}$
\end_inset

 
\emph on
e
\emph default
 megye populációja, M a nemzeti átlag 
\begin_inset Formula $M=CP/N$
\end_inset

 , úgy hogy CP az ország populációja, N az összesen generálandó körzetek
 száma.

\emph on
 A
\emph default
 megyében megengedett szórás
\emph on
 
\emph default

\begin_inset Formula $d_{e}$
\end_inset

.
 A szorzat második tagjában levő 
\begin_inset Formula $P_{s}$
\end_inset

 jelöli s körzet populációját, 
\emph on
n 
\emph default
az
\emph on
 e 
\emph default
megyéhez tartozó körzetek száma.
 Az hogy egy megyében megengedett szórás értéke mekkora, annak a függvényében
 változik, hogy a megye átlaga mennyire tér el a nemzeti átlagtól.
 Ha a két átlag közti különbség kevesebb, mint az ország lakosságának az
 5%, a megengedett szórás 15% lesz.
 5% és 10% közötti eltérés esetén a szórás 10%, míg nagyobb eltérések esetén
 a szórás 5%.
 
\begin_inset Newline newline
\end_inset

A másik objektív függvény a körzetek formájának a kompaktságát méri.
 Abból kiindulva, hogy a legkompaktabb forma a kör, mérjük a körzet kompaktságát.
 Legyen a körzethez tartozó unitok által formált alakzat kerülete 
\begin_inset Formula $PE_{s}$
\end_inset

 , területe 
\begin_inset Formula $A_{s}$
\end_inset

.
 Minnél kompaktabb a körzetünk, a kerülete annál inkább megegyezik egy 
\begin_inset Formula $A_{s}$
\end_inset

 területű kör kerületével:
\begin_inset Formula 
\[
C_{2}(P)=\ensuremath{\sum_{s\epsilon S}}(\frac{PE_{s}}{4\sqrt{A_{s}}}-1)
\]

\end_inset


\end_layout

\begin_layout Section
Románia
\end_layout

\begin_layout Chapter
Összefoglalás, eredmények
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Rin"

\end_inset

E.
 A.
 Ringcón-García, M.
 A.
 Guiterrez-Andrade et al., A Multiobjective Algorithm for Redistricting,
 Journal of Applied Research and Technology Volume 11, Issue 3, June 2013,
 Pages 324–330.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Kirk"

\end_inset

S.
 Kirkpatrick; C.
 D.
 Gelatt; M.
 P.
 Vecchi , Optimization by Simulated Annealing , Science, New Series, Vol.
 220, No.
 4598.
 (May 13, 1983), pp.
 671-680.
\end_layout

\end_body
\end_document
